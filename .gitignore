<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Typing Trainer Pro</title>
  <style>
    :root{
      --bg:#0f1221; --card:#151936; --muted:#7f86b8; --text:#e8ecff; --accent:#6ee7b7;
      --danger:#ef4444; --primary:#4f46e5; --ghost:#2e335e; --ok:#34d399; --warn:#f59e0b; --err:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;height:100%;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial}
    body{background:linear-gradient(180deg,#0f1221,#0b0e1a);color:var(--text)}
    .topbar{display:flex;gap:16px;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #1e2455;background:#0f1221;position:sticky;top:0;z-index:10}
    .brand{font-weight:700;letter-spacing:.5px}
    .controls{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
    label{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:14px}
    select, input[type="text"], input[type="number"], textarea{background:#0d1130;color:var(--text);border:1px solid #252a58;border-radius:8px;padding:10px 12px}
    select{min-width:130px}
    .primary,.secondary,.ghost,.danger{border:none;border-radius:10px;padding:10px 14px;cursor:pointer}
    .primary{background:var(--primary);color:white}
    .secondary{background:#1f2350;color:#cfd5ff}
    .ghost{background:var(--ghost);color:#cfd5ff}
    .danger{background:var(--danger);color:white}
    main.stage{max-width:1120px;margin:20px auto;padding:0 12px;display:grid;gap:16px}
    .grid{display:grid;grid-template-columns:2fr 1fr;gap:16px}
    .card{background:var(--card);border:1px solid #222759;border-radius:14px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.2)}
    .word-card .word-row{display:flex;align-items:end;justify-content:space-between}
    .word{font-size:42px;font-weight:800;letter-spacing:1px}
    .translation-row{display:flex;align-items:center;justify-content:space-between;margin-top:10px;color:var(--muted)}
    .input-row{display:flex;gap:10px;margin-top:12px;align-items:center}
    .input-row input{flex:1;font-size:20px}
    .hint{min-height:20px;font-size:12px;color:var(--muted);margin-top:6px}
    .stats-card .stats{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:8px}
    .progress .bar{height:10px;background:#0f1338;border-radius:999px;overflow:hidden;margin-top:8px;border:1px solid #23275a}
    .progress .bar span{display:block;height:100%;background:linear-gradient(90deg,#34d399,#22d3ee);width:0}
    .tiny{color:var(--muted);font-size:12px}
    .import-card textarea{width:100%;resize:vertical}
    .import-actions{display:flex;flex-wrap:wrap;gap:8px}
    .api-row{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
    .footer{max-width:1120px;margin:20px auto 40px;padding:0 12px;color:var(--muted)}
    .pill{padding:2px 8px;border:1px dashed #3a3f76;border-radius:999px}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
    .bad{outline:2px solid var(--danger); background:#1a1030}
    .good{outline:2px solid var(--ok);}
    .msg{font-size:13px;color:#b3baf5;margin-top:6px;min-height:18px}
    @media (max-width:900px){
      .grid{grid-template-columns:1fr}
      .stats-card .stats{grid-template-columns:repeat(2,minmax(0,1fr))}
      .word{font-size:32px}
    }
  </style>
  <!-- Open-source in-browser AI client (optional for API import) -->
  <script src="https://js.puter.com/v2/"></script>
</head>
<body>
  <header class="topbar">
    <div class="brand">Typing Trainer Pro <span id="netStatus" class="pill">offline</span></div>
    <div class="controls">
      <label>
        <span data-i18n="nativeLang">اللغة الأم</span>
        <select id="nativeLang">
          <option value="ar">العربية</option>
          <option value="uk">Українська</option>
        </select>
      </label>

      <label>
        <span data-i18n="targetLang">اللغة الهدف</span>
        <select id="targetLang">
          <option value="en">English</option>
          <option value="ar">العربية</option>
          <option value="uk">Українська</option>
        </select>
      </label>

      <label>
        <span data-i18n="difficulty">الصعوبة</span>
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
          <option value="adaptive">Adaptive</option>
        </select>
      </label>

      <label>
        <span data-i18n="level">المستوى</span>
        <select id="level"></select>
      </label>
    </div>
  </header>

  <main class="stage">
    <div class="grid">
      <section class="card word-card">
        <div class="word-row">
          <div class="label" data-i18n="typeThis">اكتب هذه الكلمة</div>
          <div id="currentWord" class="word">ready</div>
        </div>

        <div class="translation-row">
          <label class="inline">
            <input type="checkbox" id="toggleTranslation" checked />
            <span data-i18n="showTranslation">عرض الترجمة الفورية</span>
          </label>
          <div id="translation" class="translation">—</div>
        </div>

        <div class="input-row">
          <input id="answer" type="text" autocomplete="off" placeholder="Type here…" />
          <button id="btnSkip" class="ghost" data-i18n="skip">تخطي</button>
        </div>

        <div id="assistHint" class="hint"></div>
        <div id="msg" class="msg"></div>

        <div class="tiny" style="margin-top:8px">
          <label><input type="checkbox" id="autoSpeak" /> <span data-i18n="autoSpeak">نطق تلقائي</span></label>
          <span class="pill tiny" data-i18n="ttsHint" style="margin-inline-start:8px">النطق يعتمد على دعم متصفحك للأصوات.</span>
        </div>

        <div class="tiny" style="margin-top:6px;display:flex;flex-wrap:wrap;gap:12px">
          <label><input type="checkbox" id="trainingMode" /> <span data-i18n="trainingMode">وضع تدريب (بدون عداد وتصحيح فوري)</span></label>
          <label><input type="checkbox" id="autoAccept" checked /> <span data-i18n="autoAccept">قبول تلقائي عند التطابق الكامل</span></label>
          <label><input type="checkbox" id="allowRepeats" /> <span data-i18n="allowRepeats">السماح بالتكرار</span></label>
          <span id="deckStatus" class="pill tiny">deck: —</span>
        </div>
      </section>

      <section class="card stats-card">
        <div class="stats">
          <div><strong data-i18n="scoreLabel">النتيجة:</strong> <span id="score">0</span></div>
          <div><strong data-i18n="streakLabel">سلسلة:</strong> <span id="streak">0</span></div>
          <div><strong data-i18n="accuracyLabel">الدقة:</strong> <span id="accuracy">100%</span></div>
          <div><strong data-i18n="timeLabel">الوقت:</strong> <span id="timeLeft">—</span></div>
        </div>
        <div class="progress">
          <div class="bar"><span id="levelProgress" style="width:0%"></span></div>
          <div class="tiny"><span id="progressLabel">0 / 0</span></div>
        </div>

        <div class="tiny" style="margin-top:10px">
          <button id="btnStart" class="primary" data-i18n="start">ابدأ</button>
          <button id="btnPause" class="secondary" data-i18n="pause">إيقاف</button>
        </div>
      </section>
    </div>

    <section class="card import-card">
      <h3 data-i18n="importHeader">استيراد كلمات</h3>
      <p class="tiny" data-i18n="importHint">الصيغة: target[,native]. أمثلة: hello,مرحبا — apple,تفاحة — book</p>
      <textarea id="importBox" rows="4" placeholder="apple,تفاحة"></textarea>
      <div class="import-actions">
        <button id="btnImport" class="secondary" data-i18n="import">استيراد يدوي</button>
        <button id="btnExport" class="ghost" data-i18n="export">تصدير التقدم</button>
        <button id="btnReset" class="danger" data-i18n="reset">إعادة ضبط</button>
      </div>

      <h4 style="margin-top:16px" data-i18n="apiHeader">الاستيراد من API (مفتوح المصدر)</h4>
      <div class="api-row">
        <input id="apiTopic" type="text" placeholder="موضوع (اختياري): travel, food..." />
        <input id="apiCount" type="number" min="5" max="200" value="40" />
        <button id="btnFetchAPI" class="primary" data-i18n="fetch">جلب الآن</button>
        <label class="tiny"><input type="checkbox" id="autoAPI" /> <span data-i18n="autoAPI">استيراد تلقائي عند الحاجة</span></label>
        <span id="apiStatus" class="tiny pill">idle</span>
      </div>
      <p class="tiny" data-i18n="apiHint">يتطلب اتصالًا بالإنترنت. يتم حفظ النتائج محليًا واستخدامها لاحقًا بدون إنترنت.</p>
    </section>

    <section class="card notes-card">
      <details>
        <summary data-i18n="tipsTitle">نصائح</summary>
        <ul class="tiny" style="margin:8px 0 0 16px">
          <li data-i18n="tip1">وضع التدريب يلغي العداد ويصحح الأخطاء لحظيًا ويقبل الإجابة تلقائيًا عند التطابق.</li>
          <li data-i18n="tip2">لا تكرار: كل الكلمات تُسحب من رزمة عشوائية بدون تكرار حتى تنفد.</li>
          <li data-i18n="tip3">الاستيراد التلقائي يجلب مستوى جديدًا عند نفاد الكلمات.</li>
          <li data-i18n="tip4">يمكن تعديل الترجمة بالنقر عليها — تُحفظ فورًا.</li>
        </ul>
      </details>
    </section>
  </main>

  <footer class="footer tiny">
    <span>Local-first with smart online boosts. Auto-save. No account needed.</span>
  </footer>

  <script>
    // ================= Default packs =================
    const DEFAULT_WORD_PACKS = {
      "ar->en": {
        name: "أساسيات EN",
        levels: [
          [
            ["hello","مرحبا"],["cat","قطة"],["water","ماء"],
            ["book","كتاب"],["world","عالم"],["house","منزل"]
          ],
          [
            ["beautiful","جميل"],["computer","حاسوب"],["library","مكتبة"],
            ["teacher","معلم"],["student","طالب"],["family","عائلة"]
          ]
        ]
      },
      "uk->en": {
        name: "База EN",
        levels: [
          [
            ["hello","привіт"],["cat","кіт"],["water","вода"],
            ["book","книга"],["world","світ"],["house","дім"]
          ],
          [
            ["beautiful","красивий"],["computer","комп’ютер"],["library","бібліотека"],
            ["teacher","вчитель"],["student","студент"],["family","сім’я"]
          ]
        ]
      },
      "ar->ar": { name:"مفردات عربية", levels: [ [ ["سلام","سلام"],["قلم","قلم"],["مطر","مطر"] ] ] },
      "uk->uk": { name:"Українська", levels: [ [ ["слово","слово"],["сонце","сонце"],["місто","місто"] ] ] },
      "ar->uk": { name:"عربي → أوكراني", levels: [ [ ["بيت","дім"],["كتاب","книга"],["قهوة","кава"] ] ] },
      "uk->ar": { name:"Українська → عربية", levels: [ [ ["дім","بيت"],["كнига","كتاب"],["кава","قهوة"] ] ] },
    };

    // ================= Helpers & State =================
    const $ = (s)=>document.querySelector(s);
    const STORAGE_KEY = "typing-trainer/v3-pro";
    const API_CACHE_KEY = "typing-trainer/api-cache";

    const UI_I18N = {
      ar: {
        nativeLang: "اللغة الأم",
        targetLang: "اللغة الهدف",
        difficulty: "الصعوبة",
        level: "المستوى",
        start: "ابدأ",
        pause: "إيقاف",
        typeThis: "اكتب هذه الكلمة",
        showTranslation: "عرض الترجمة الفورية",
        skip: "تخطي",
        scoreLabel: "النتيجة:",
        streakLabel: "سلسلة:",
        accuracyLabel: "الدقة:",
        timeLabel: "الوقت:",
        importHeader: "استيراد كلمات",
        importHint: "الصيغة: target[,native]. مثال: hello,مرحبا — بدون ترجمة؟ أضفها لاحقًا.",
        import: "استيراد يدوي",
        export: "تصدير التقدم",
        reset: "إعادة ضبط",
        tipsTitle: "نصائح",
        tip1: "وضع التدريب يلغي العداد ويقبل الكلمة تلقائيًا عند التطابق.",
        tip2: "لا تكرار داخل المستوى حتى تنفد الكلمات.",
        tip3: "الاستيراد التلقائي يجلب مستوى جديدًا عند الحاجة.",
        tip4: "ترجمة قابلة للتعديل بالنقر.",
        apiHeader: "الاستيراد من API (مفتوح المصدر)",
        fetch: "جلب الآن",
        apiHint: "يتطلب إنترنت. النتائج تُحفظ محليًا.",
        autoSpeak: "نطق تلقائي",
        ttsHint: "النطق يعتمد على دعم متصفحك للأصوات.",
        trainingMode: "وضع تدريب (بدون عداد وتصحيح فوري)",
        autoAccept: "قبول تلقائي عند التطابق الكامل",
        allowRepeats: "السماح بالتكرار",
        autoAPI: "استيراد تلقائي عند الحاجة"
      },
      uk: {
        nativeLang: "Рідна мова",
        targetLang: "Мова вивчення",
        difficulty: "Складність",
        level: "Рівень",
        start: "Старт",
        pause: "Пауза",
        typeThis: "Набери це слово",
        showTranslation: "Миттєвий переклад",
        skip: "Пропустити",
        scoreLabel: "Бал:",
        streakLabel: "Серія:",
        accuracyLabel: "Точність:",
        timeLabel: "Час:",
        importHeader: "Імпорт слів",
        importHint: "Формат: target[,native]. Напр.: hello,привіт.",
        import: "Імпорт вручну",
        export: "Експорт прогресу",
        reset: "Скинути",
        tipsTitle: "Підказки",
        tip1: "Тренувальний режим без таймера з авто-прийняттям.",
        tip2: "Без повторів у межах рівня.",
        tip3: "Автоімпорт додає новий рівень за потреби.",
        tip4: "Переклад редагується кліком.",
        apiHeader: "Імпорт з відкритого API",
        fetch: "Отримати",
        apiHint: "Потрібен інтернет. Результати кешуються.",
        autoSpeak: "Автовимова",
        ttsHint: "Вимова залежить від підтримки голосів.",
        trainingMode: "Тренувальний режим (без таймера)",
        autoAccept: "Автоприйом при повному збігу",
        allowRepeats: "Дозволити повтори",
        autoAPI: "Автоімпорт за потреби"
      }
    };

    const DIFF = {
      easy:   { timePerWord: 14, penalty: 0.5, reward: 2, targetLen: [2,7] },
      normal: { timePerWord: 10, penalty: 1,   reward: 3, targetLen: [3,10] },
      hard:   { timePerWord: 7,  penalty: 1.5, reward: 5, targetLen: [5,16] },
    };

    const state = {
      native: "ar",
      target: "en",
      difficulty: "normal",
      levelIndex: 0,
      running: false,
      timer: null,
      timeLeft: 0,
      words: [],
      deck: [],           // shuffled indices (no repeats)
      idx: -1,           // current index in words
      score: 0,
      correct: 0,
      attempts: 0,
      streak: 0,
      packs: {},
      allPacks: {},
      userTranslations: {},
      autoSpeak: false,
      voices: [],
      trainingMode: false,
      autoAccept: true,
      allowRepeats: false,
      autoAPI: false
    };

    function netBadge(){
      const el = $("#netStatus");
      const online = navigator.onLine;
      el.textContent = online ? "online" : "offline";
      el.className = "pill " + (online ? "ok" : "warn");
    }
    window.addEventListener("online", netBadge);
    window.addEventListener("offline", netBadge);

    // ================= Storage =================
    function loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return;
        Object.assign(state, JSON.parse(raw));
      }catch(e){}
    }
    function saveState(){
      const {timer, voices, ...persist} = state;
      localStorage.setItem(STORAGE_KEY, JSON.stringify(persist));
    }

    // ================= Packs merge =================
    function mergePacks(){
      const base = JSON.parse(JSON.stringify(DEFAULT_WORD_PACKS));
      if(state.packs){
        for(const k of Object.keys(state.packs)){
          if(!base[k]) base[k] = { name:"Imported", levels: [] };
          base[k].levels = (base[k].levels||[]).concat(state.packs[k].levels||[]);
        }
      }
      return base;
    }
    function getPackKey(n,t){ return n+"->"+t; }

    // ================= I18N =================
    function applyI18n(){
      const dict = UI_I18N[state.native] || UI_I18N.ar;
      document.querySelectorAll("[data-i18n]").forEach(el=>{
        const key = el.getAttribute("data-i18n");
        if(dict[key]) el.textContent = dict[key];
      });
      if(state.native === "ar"){ document.documentElement.lang="ar"; document.documentElement.dir="rtl"; }
      else { document.documentElement.lang="uk"; document.documentElement.dir="ltr"; }
    }

    // ================= Levels/Words/Deck =================
    function rebuildLevels(){
      const sel = $("#level");
      sel.innerHTML = "";
      const key = getPackKey(state.native, state.target);
      const pack = state.allPacks[key];
      const count = pack ? (pack.levels?.length||0) : 0;

      if(count === 0){
        const opt = document.createElement("option");
        opt.value = "0"; opt.textContent = "Level 1";
        sel.appendChild(opt);
        state.levelIndex = 0;
        state.words = [];
        state.deck = [];
        updateDeckStatus();
        return;
      }
      for(let i=0;i<count;i++){
        const opt = document.createElement("option");
        opt.value = String(i);
        opt.textContent = `Level ${i+1}`;
        sel.appendChild(opt);
      }
      if(state.levelIndex >= count) state.levelIndex = count-1;
      sel.value = String(state.levelIndex);
      loadLevelWords();
    }

    function loadLevelWords(){
      const key = getPackKey(state.native, state.target);
      const pack = state.allPacks[key];
      const list = (pack?.levels?.[state.levelIndex] || []).map(([t,n])=>({t, n}));
      state.words = list;
      buildDeck();
      updateProgress();
    }

    function buildDeck(){
      const n = state.words.length;
      state.deck = [];
      for(let i=0;i<n;i++) state.deck.push(i);
      // shuffle
      for(let i=n-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [state.deck[i], state.deck[j]] = [state.deck[j], state.deck[i]];
      }
      updateDeckStatus();
    }

    function nextFromDeck(){
      if(state.allowRepeats){
        return Math.floor(Math.random()*Math.max(1, state.words.length));
      }
      if(state.deck.length === 0) return -1;
      return state.deck.pop();
    }

    function updateDeckStatus(){
      const total = state.words.length;
      const left = state.allowRepeats ? "∞" : state.deck.length;
      $("#deckStatus").textContent = `deck: ${left} / ${total}`;
    }

    function currentTranslation(word){
      const key = `${state.target}|${state.native}|${word}`;
      return state.userTranslations[key] || state.words.find(w=>w.t===word)?.n || "—";
    }

    function setCurrentWord({speak=true}={}){
      if(state.words.length === 0){
        $("#currentWord").textContent = "—";
        $("#translation").textContent = "—";
        $("#assistHint").textContent = "";
        $("#msg").textContent = "";
        return;
      }
      // pull next index; if empty and autoAPI enabled -> fetch
      let i = nextFromDeck();
      if(i === -1){
        updateDeckStatus();
        if(state.autoAPI){
          triggerAutoAPI().then(()=>{ /* new level added */ }).catch(()=>{});
        }
        // Rebuild deck or stay if repeats allowed
        if(!state.allowRepeats){ buildDeck(); i = nextFromDeck(); }
        if(i === -1){ // still no words
          $("#currentWord").textContent = "—";
          $("#translation").textContent = "—";
          $("#assistHint").textContent = "";
          return;
        }
      }
      state.idx = i;
      const w = state.words[state.idx].t;
      $("#currentWord").textContent = w;
      const trans = state.trainingMode ? currentTranslation(w) : ($("#toggleTranslation").checked ? currentTranslation(w) : "—");
      $("#translation").textContent = trans;
      const ans = $("#answer");
      ans.value = "";
      $("#assistHint").textContent = "";
      $("#msg").textContent = "";
      ans.classList.remove("bad","good");
      ans.focus();
      if(!state.trainingMode) resetTimer(); else { clearInterval(state.timer); $("#timeLeft").textContent = "—"; }
      speakIfEnabled(w);
    }

    function resetTimer(){
      clearInterval(state.timer);
      if(state.trainingMode){ $("#timeLeft").textContent = "—"; return; }
      const base = DIFF[state.difficulty] || DIFF.normal;
      let time = base.timePerWord;
      if(state.difficulty === "adaptive"){
        const acc = accuracyValue();
        if(acc >= 95) time += 2;
        else if(acc <= 80) time -= 2;
        time = Math.max(4, Math.min(18, time));
      }
      state.timeLeft = time;
      $("#timeLeft").textContent = `${state.timeLeft}s`;
      state.timer = setInterval(()=>{
        state.timeLeft--;
        if(state.timeLeft <= 0){
          clearInterval(state.timer);
          onMistake("timeout");
          setCurrentWord();
        }
        $("#timeLeft").textContent = `${Math.max(0,state.timeLeft)}s`;
      }, 1000);
    }

    function accuracyValue(){
      const {correct, attempts} = state;
      if(attempts===0) return 100;
      return Math.round((correct/attempts)*100);
    }

    function updateStats(){
      $("#score").textContent = state.score;
      $("#streak").textContent = state.streak;
      $("#accuracy").textContent = `${accuracyValue()}%`;
    }

    function updateProgress(){
      const done = state.correct;
      const total = state.words.length || 0;
      const pct = total>0 ? Math.min(100, Math.round((done%total)/total*100)) : 0;
      $("#levelProgress").style.width = `${pct}%`;
      $("#progressLabel").textContent = `${done%Math.max(total,1)} / ${total}`;
      updateStats();
      updateDeckStatus();
    }

    function onCorrect(){
      const base = DIFF[state.difficulty] || DIFF.normal;
      state.score += base.reward;
      state.correct++;
      state.attempts++;
      state.streak++;
      saveState();
      updateProgress();
      praise();
    }

    function onMistake(){
      const base = DIFF[state.difficulty] || DIFF.normal;
      if(!state.trainingMode){
        state.score = Math.max(0, state.score - base.penalty);
      }
      state.attempts++;
      state.streak = 0;
      saveState();
      updateProgress();
    }

    function praise(){
      const msgs = ["تمام!","ممتاز!","جميل جدًا!","Great!","Nice!","Браво!"];
      $("#msg").textContent = msgs[Math.floor(Math.random()*msgs.length)];
    }

    function tryAnswerEnter(){
      // Enter key handler (still supported)
      if(state.words.length === 0 || state.idx<0) return;
      const target = state.words[state.idx].t;
      const val = $("#answer").value.trim();
      if(val === "") return;
      if(equalsIgnoreCase(val, target)){
        onCorrect();
        setCurrentWord();
      } else {
        onMistake();
      }
    }

    // Live validation + auto-accept
    function onInputChanged(){
      if(state.words.length === 0 || state.idx<0) return;
      const target = state.words[state.idx].t;
      const val = $("#answer").value;
      const ans = $("#answer");
      const hint = $("#assistHint");

      // prefix check (case-insensitive)
      const isPrefix = target.toLowerCase().startsWith(val.toLowerCase());
      if(val.length === 0){
        ans.classList.remove("bad","good");
        hint.textContent = "";
        return;
      }
      if(isPrefix){
        ans.classList.remove("bad");
        ans.classList.add("good");
        hint.textContent = "";
      } else {
        ans.classList.remove("good");
        ans.classList.add("bad");
        hint.textContent = "تحقق من الحروف…";
        if(!state.trainingMode){
          // optional: light penalty per mismatch in non-training
        }
      }
      // auto-accept when full match
      if(state.autoAccept && equalsIgnoreCase(val.trim(), target)){
        onCorrect();
        setCurrentWord();
      }
    }

    function equalsIgnoreCase(a,b){ return a.localeCompare(b, undefined, {sensitivity:"accent"})===0; }

    function toggleRun(run){
      state.running = run;
      $("#btnStart").disabled = run;
      $("#btnPause").disabled = !run;
      $("#answer").disabled = !run;
      $("#btnSkip").disabled = !run;
      if(run){ setCurrentWord({speak:false}); setTimeout(()=>speakIfEnabled($("#currentWord").textContent),50); } else { clearInterval(state.timer); }
    }

    // ================= Import/Export/Reset (with dedupe across levels) =================
    function parseImport(text){
      const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      const raw = lines.map(line=>{
        // Allow comma or semicolon; normalize to comma
        const parts = line.split(/[;,]/);
        const t = (parts[0]||"").trim();
        const n = (parts[1]||"").trim();
        return [t,n];
      }).filter(([t])=>t.length>0);
      return sanitizePairs(raw);
    }

    function buildExistingSet(native, target){
      const set = new Set();
      const key = getPackKey(native, target);
      const pack = state.allPacks[key];
      const levels = pack?.levels || [];
      for(const lvl of levels){
        for(const [t] of lvl){
          set.add((t||"").toLowerCase());
        }
      }
      return set;
    }

    function sanitizePairs(pairs){
      // Remove empty, trim, length guard, dedupe within import
      const seen = new Set();
      const out = [];
      for(const [tRaw,nRaw] of pairs){
        const t = (tRaw||"").trim();
        const n = (nRaw||"").trim();
        if(!t) continue;
        if(t.length>64 || n.length>96) continue;
        const k = t.toLowerCase();
        if(seen.has(k)) continue;
        out.push([t,n]);
        seen.add(k);
      }
      // Dedupe against existing across all levels for this pair
      const existing = buildExistingSet(state.native, state.target);
      return out.filter(([t])=>!existing.has((t||"").toLowerCase()));
    }

    function addImportedAsNewLevel(pairs){
      if(!pairs || pairs.length===0) return false;
      const key = getPackKey(state.native, state.target);
      if(!state.packs[key]) state.packs[key] = { name:"Imported", levels: [] };
      state.packs[key].levels.push(pairs);
      state.allPacks = mergePacks();
      rebuildLevels();
      state.levelIndex = (state.allPacks[key].levels.length - 1);
      $("#level").value = String(state.levelIndex);
      loadLevelWords();
      saveState();
      return true;
    }

    function exportProgress(){
      const payload = {
        native: state.native,
        target: state.target,
        difficulty: state.difficulty,
        levelIndex: state.levelIndex,
        score: state.score,
        correct: state.correct,
        attempts: state.attempts,
        streak: state.streak,
        userTranslations: state.userTranslations,
        packs: state.packs,
        settings: {
          trainingMode: state.trainingMode,
          autoSpeak: state.autoSpeak,
          autoAccept: state.autoAccept,
          allowRepeats: state.allowRepeats,
          autoAPI: state.autoAPI
        }
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "typing-trainer-progress.json";
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 3000);
    }

    function resetAll(){
      if(!confirm("Reset all progress and imported words?")) return;
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(API_CACHE_KEY);
      location.reload();
    }

    // ================= Inline translation edit =================
    function enableInlineTranslation(){
      const el = $("#translation");
      el.contentEditable = "true";
      el.addEventListener("input", ()=>{
        const cw = $("#currentWord").textContent;
        const key = `${state.target}|${state.native}|${cw}`;
        state.userTranslations[key] = el.textContent.trim();
        saveState();
      });
    }

    // ================= TTS (Web Speech API) =================
    function loadVoices(){
      try{ state.voices = speechSynthesis.getVoices(); }catch(e){ state.voices = []; }
    }
    function langCodeForTarget(){
      const t = state.target;
      if(t === "en") return "en-US";
      if(t === "ar") return "ar-SA";
      if(t === "uk") return "uk-UA";
      return "en-US";
    }
    function pickVoice(langPref){
      if(!state.voices || state.voices.length===0) return null;
      const exact = state.voices.find(v=>v.lang.toLowerCase()===langPref.toLowerCase());
      if(exact) return exact;
      const base = langPref.split("-")[0];
      const partial = state.voices.find(v=>v.lang.toLowerCase().startsWith(base.toLowerCase()));
      return partial || state.voices[0];
    }
    function speakIfEnabled(text){
      if(!state.autoSpeak || !text || text==="—" || text==="ready") return;
      try{
        window.speechSynthesis.cancel();
        const uttr = new SpeechSynthesisUtterance(text);
        const lang = langCodeForTarget();
        uttr.lang = lang;
        const voice = pickVoice(lang);
        if(voice) uttr.voice = voice;
        uttr.rate = 0.95;
        uttr.pitch = 1.0;
        speechSynthesis.speak(uttr);
      }catch(e){}
    }
    if("speechSynthesis" in window){
      loadVoices();
      window.speechSynthesis.onvoiceschanged = loadVoices;
    }

    // ================= Open API fetch (with retries + caching) =================
    function cacheAPIPairs(native, target, topic, pairs){
      try{
        const raw = localStorage.getItem(API_CACHE_KEY);
        const cache = raw ? JSON.parse(raw) : {};
        const key = `${native}|${target}|${(topic||"_").toLowerCase()}`;
        cache[key] = { time: Date.now(), pairs };
        localStorage.setItem(API_CACHE_KEY, JSON.stringify(cache));
      }catch(e){}
    }

    function getCachedPairs(native, target, topic){
      try{
        const raw = localStorage.getItem(API_CACHE_KEY);
        if(!raw) return null;
        const cache = JSON.parse(raw);
        const key = `${native}|${target}|${(topic||"_").toLowerCase()}`;
        return cache[key]?.pairs || null;
      }catch(e){ return null; }
    }

    async function fetchFromAPIOnce(topic, count){
      // Guard: client available
      if(!(window.puter && puter.ai && puter.ai.chat)) throw new Error("API client unavailable");
      const dict = UI_I18N[state.native] || UI_I18N.ar;
      const nativeName = state.native;
      const targetName = state.target;
      const prompt = [
        `Generate ${count} ${targetName.toUpperCase()} words${topic? " about "+topic : ""} with ${nativeName.toUpperCase()} translations.`,
        `Rules:`,
        `- Output ONLY lines in CSV: target,translation`,
        `- No numbering, no extra commentary.`,
        `- Use common, learner-friendly terms.`,
      ].join("\n");
      const resp = await puter.ai.chat(prompt, { model: 'google/gemini-2.0-flash-lite-001' });
      const text = (resp?.message?.content || "").trim();
      if(!text) throw new Error("Empty response");
      const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      const parsed = lines.map(line=>{
        // remove surrounding quotes and split by first comma
        const cleaned = line.replace(/^["']|["']$/g,"");
        const idx = cleaned.indexOf(",");
        if(idx===-1) return [cleaned.trim(),""];
        const t = cleaned.slice(0,idx).trim().replace(/^["']|["']$/g,"");
        const n = cleaned.slice(idx+1).trim().replace(/^["']|["']$/g,"");
        return [t,n];
      });
      // sanitize + global dedupe
      const pairs = sanitizePairs(parsed);
      return pairs;
    }

    async function fetchWordsFromAPI(topic, count, retries=2){
      const status = $("#apiStatus");
      if(!navigator.onLine) throw new Error("Offline");
      status.textContent = "fetching...";
      status.className = "tiny pill warn";
      let lastErr = null;
      for(let attempt=0; attempt<=retries; attempt++){
        try{
          const pairs = await fetchFromAPIOnce(topic, count);
          if(pairs && pairs.length>0){
            cacheAPIPairs(state.native, state.target, topic, pairs);
            status.textContent = `ok: ${pairs.length}`;
            status.className = "tiny pill ok";
            return pairs;
          }
        }catch(e){ lastErr = e; await sleep(400*(attempt+1)); }
      }
      status.textContent = "failed";
      status.className = "tiny pill err";
      if(lastErr) throw lastErr;
      throw new Error("Fetch failed");
    }

    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

    async function triggerAutoAPI(){
      // Try live; on failure use cache
      const topic = $("#apiTopic").value.trim();
      const count = Math.max(10, Math.min(200, parseInt($("#apiCount").value,10)||40));
      try{
        const pairs = await fetchWordsFromAPI(topic, count, 2);
        addImportedAsNewLevel(pairs);
        return true;
      }catch(e){
        const cached = getCachedPairs(state.native, state.target, topic);
        if(cached && cached.length>0){
          addImportedAsNewLevel(cached);
          $("#apiStatus").textContent = `cached ${cached.length}`;
          $("#apiStatus").className = "tiny pill ok";
          return true;
        }
        return false;
      }
    }

    // ================= Events =================
    function bindEvents(){
      $("#nativeLang").addEventListener("change", (e)=>{
        state.native = e.target.value;
        applyI18n();
        state.allPacks = mergePacks();
        rebuildLevels();
        saveState();
      });
      $("#targetLang").addEventListener("change", (e)=>{
        state.target = e.target.value;
        state.allPacks = mergePacks();
        rebuildLevels();
        saveState();
      });
      $("#difficulty").addEventListener("change", (e)=>{
        state.difficulty = e.target.value;
        saveState();
      });
      $("#level").addEventListener("change", (e)=>{
        state.levelIndex = parseInt(e.target.value,10)||0;
        loadLevelWords();
        saveState();
      });

      $("#autoSpeak").addEventListener("change", (e)=>{
        state.autoSpeak = e.target.checked; saveState();
        if(state.autoSpeak){
          const w = $("#currentWord").textContent;
          if(w && w!=="ready" && w!=="—") speakIfEnabled(w);
        } else { try{ speechSynthesis.cancel(); }catch(e){} }
      });
      $("#trainingMode").addEventListener("change", (e)=>{
        state.trainingMode = e.target.checked; saveState();
        if(state.trainingMode){ clearInterval(state.timer); $("#timeLeft").textContent = "—"; $("#toggleTranslation").checked = true; }
      });
      $("#autoAccept").addEventListener("change", (e)=>{ state.autoAccept = e.target.checked; saveState(); });
      $("#allowRepeats").addEventListener("change", (e)=>{ state.allowRepeats = e.target.checked; saveState(); updateDeckStatus(); });

      $("#btnStart").addEventListener("click", ()=>toggleRun(true));
      $("#btnPause").addEventListener("click", ()=>toggleRun(false));
      $("#btnSkip").addEventListener("click", ()=>{
        onMistake();
        setCurrentWord();
      });
      $("#toggleTranslation").addEventListener("change", ()=>{
        const cw = $("#currentWord").textContent;
        $("#translation").textContent = (state.trainingMode || $("#toggleTranslation").checked) ? currentTranslation(cw) : "—";
      });
      $("#answer").addEventListener("keydown", (e)=>{
        if(e.key === "Enter"){ e.preventDefault(); tryAnswerEnter(); }
      });
      $("#answer").addEventListener("input", onInputChanged);

      $("#btnImport").addEventListener("click", ()=>{
        const txt = $("#importBox").value.trim();
        if(!txt) return;
        const pairs = parseImport(txt);
        if(pairs.length === 0){ flashMsg("لا توجد كلمات جديدة بعد التنقية."); return; }
        addImportedAsNewLevel(pairs);
        $("#importBox").value = "";
        flashMsg(`تمت إضافة ${pairs.length} كلمة.`);
      });
      $("#btnExport").addEventListener("click", exportProgress);
      $("#btnReset").addEventListener("click", resetAll);

      $("#btnFetchAPI").addEventListener("click", async ()=>{
        const ok = await triggerAutoAPI();
        if(ok) flashMsg("تم جلب مستوى جديد من الـ API.");
        else flashMsg("تعذر الجلب، ولا يوجد كاش مناسب.", true);
      });
      $("#autoAPI").addEventListener("change", (e)=>{ state.autoAPI = e.target.checked; saveState(); });
    }

    function flashMsg(text, isErr=false){
      const m = $("#msg");
      m.textContent = text;
      m.style.color = isErr ? "var(--err)" : "#b3baf5";
      setTimeout(()=>{ if($("#msg").textContent===text) m.textContent=""; }, 3000);
    }

    // ================= Init =================
    function init(){
      netBadge();
      loadState();

      state.native = state.native || "ar";
      state.target = state.target || "en";
      state.difficulty = state.difficulty || "normal";
      state.levelIndex = state.levelIndex || 0;
      state.packs = state.packs || {};
      state.userTranslations = state.userTranslations || {};
      state.autoSpeak = !!state.autoSpeak;
      state.trainingMode = !!state.trainingMode;
      state.autoAccept = state.autoAccept !== false;
      state.allowRepeats = !!state.allowRepeats;
      state.autoAPI = !!state.autoAPI;

      state.allPacks = mergePacks();
      applyI18n();

      $("#nativeLang").value = state.native;
      $("#targetLang").value = state.target;
      $("#difficulty").value = state.difficulty;
      $("#autoSpeak").checked = state.autoSpeak;
      $("#trainingMode").checked = state.trainingMode;
      $("#autoAccept").checked = state.autoAccept;
      $("#allowRepeats").checked = state.allowRepeats;
      $("#autoAPI").checked = state.autoAPI;

      rebuildLevels();
      enableInlineTranslation();
      bindEvents();
      updateStats();

      $("#currentWord").textContent = "ready";
      $("#translation").textContent = "—";
      $("#answer").disabled = true;
      $("#btnPause").disabled = true;
      $("#btnSkip").disabled = true;
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
